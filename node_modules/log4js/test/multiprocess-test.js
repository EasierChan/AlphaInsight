"use strict";function makeFakeNet(){return{logEvents:[],data:[],cbs:{},createConnectionCalled:0,fakeAppender:function(e){this.logEvents.push(e)},createConnection:function(e,t){var s=this;return this.port=e,this.host=t,this.createConnectionCalled+=1,{on:function(e,t){s.cbs[e]=t},write:function(e,t){s.data.push(e),s.encoding=t},end:function(){s.closeCalled=!0}}},createServer:function(e){var t=this;return e({remoteAddress:"1.2.3.4",remotePort:"1234",setEncoding:function(e){t.encoding=e},on:function(e,s){t.cbs[e]=s}}),{listen:function(e,s){t.port=e,t.host=s}}}}}var vows=require("vows"),sandbox=require("sandboxed-module"),assert=require("assert");vows.describe("Multiprocess Appender").addBatch({worker:{topic:function(){var e=makeFakeNet(),t=sandbox.require("../lib/appenders/multiprocess",{requires:{net:e}}).appender({mode:"worker",loggerPort:1234,loggerHost:"pants"});return t("before connect"),e.cbs.connect(),t("after connect"),e.cbs.close(!0),t("after error, before connect"),e.cbs.connect(),t("after error, after connect"),t(new Error("Error test")),e},"should open a socket to the loggerPort and loggerHost":function(e){assert.equal(e.port,1234),assert.equal(e.host,"pants")},"should buffer messages written before socket is connected":function(e){assert.equal(e.data[0],JSON.stringify("before connect"))},"should write log messages to socket as json strings with a terminator string":function(e){assert.equal(e.data[0],JSON.stringify("before connect")),assert.equal(e.data[1],"__LOG4JS__"),assert.equal(e.data[2],JSON.stringify("after connect")),assert.equal(e.data[3],"__LOG4JS__"),assert.equal(e.encoding,"utf8")},"should attempt to re-open the socket on error":function(e){assert.equal(e.data[4],JSON.stringify("after error, before connect")),assert.equal(e.data[5],"__LOG4JS__"),assert.equal(e.data[6],JSON.stringify("after error, after connect")),assert.equal(e.data[7],"__LOG4JS__"),assert.equal(e.createConnectionCalled,2)},"should serialize an Error correctly":function(e){assert(JSON.parse(e.data[8]).stack,"Expected:\n\n"+e.data[8]+"\n\n to have a 'stack' property");var t=JSON.parse(e.data[8]).stack,s=/^Error: Error test/;assert(t.match(s),"Expected: \n\n "+t+"\n\n to match "+s)}},"worker with timeout":{topic:function(){var e=makeFakeNet(),t=sandbox.require("../lib/appenders/multiprocess",{requires:{net:e}}).appender({mode:"worker"});return t("before connect"),e.cbs.connect(),t("after connect"),e.cbs.timeout(),t("after timeout, before close"),e.cbs.close(),t("after close, before connect"),e.cbs.connect(),t("after close, after connect"),e},"should attempt to re-open the socket":function(e){assert.equal(e.data[0],JSON.stringify("before connect")),assert.equal(e.data[2],JSON.stringify("after connect")),assert.equal(e.data[4],JSON.stringify("after timeout, before close")),assert.equal(e.data[6],JSON.stringify("after close, before connect")),assert.equal(e.data[8],JSON.stringify("after close, after connect")),assert.equal(e.createConnectionCalled,2)}},"worker defaults":{topic:function(){var e=makeFakeNet();sandbox.require("../lib/appenders/multiprocess",{requires:{net:e}}).appender({mode:"worker"});return e},"should open a socket to localhost:5000":function(e){assert.equal(e.port,5e3),assert.equal(e.host,"localhost")}},master:{topic:function(){var e=makeFakeNet(),t=sandbox.require("../lib/appenders/multiprocess",{requires:{net:e}}).appender({mode:"master",loggerHost:"server",loggerPort:1234,actualAppender:e.fakeAppender.bind(e)});return t("this should be sent to the actual appender directly"),e},"should listen for log messages on loggerPort and loggerHost":function(e){assert.equal(e.port,1234),assert.equal(e.host,"server")},"should return the underlying appender":function(e){assert.equal(e.logEvents[0],"this should be sent to the actual appender directly")},"when a client connects":{topic:function(e){var t=JSON.stringify({level:{level:1e4,levelStr:"DEBUG"},data:["some debug"]})+"__LOG4JS__";return e.cbs.data(JSON.stringify({level:{level:4e4,levelStr:"ERROR"},data:["an error message"]})+"__LOG4JS__"),e.cbs.data(t.substring(0,10)),e.cbs.data(t.substring(10)),e.cbs.data(t+t+t),e.cbs.end(JSON.stringify({level:{level:5e4,levelStr:"FATAL"},data:["that's all folks"]})+"__LOG4JS__"),e.cbs.data("bad message__LOG4JS__"),e},"should parse log messages into log events and send to appender":function(e){assert.equal(e.logEvents[1].level.toString(),"ERROR"),assert.equal(e.logEvents[1].data[0],"an error message"),assert.equal(e.logEvents[1].remoteAddress,"1.2.3.4"),assert.equal(e.logEvents[1].remotePort,"1234")},"should parse log messages split into multiple chunks":function(e){assert.equal(e.logEvents[2].level.toString(),"DEBUG"),assert.equal(e.logEvents[2].data[0],"some debug"),assert.equal(e.logEvents[2].remoteAddress,"1.2.3.4"),assert.equal(e.logEvents[2].remotePort,"1234")},"should parse multiple log messages in a single chunk":function(e){assert.equal(e.logEvents[3].data[0],"some debug"),assert.equal(e.logEvents[4].data[0],"some debug"),assert.equal(e.logEvents[5].data[0],"some debug")},"should handle log messages sent as part of end event":function(e){assert.equal(e.logEvents[6].data[0],"that's all folks")},"should handle unparseable log messages":function(e){assert.equal(e.logEvents[7].level.toString(),"ERROR"),assert.equal(e.logEvents[7].categoryName,"log4js"),assert.equal(e.logEvents[7].data[0],"Unable to parse log:"),assert.equal(e.logEvents[7].data[1],"bad message")}}},"master defaults":{topic:function(){var e=makeFakeNet();sandbox.require("../lib/appenders/multiprocess",{requires:{net:e}}).appender({mode:"master"});return e},"should listen for log messages on localhost:5000":function(e){assert.equal(e.port,5e3),assert.equal(e.host,"localhost")}}}).addBatch({configure:{topic:function(){var e={},t=makeFakeNet();sandbox.require("../lib/appenders/multiprocess",{requires:{net:t,"../log4js":{loadAppender:function(t){e.appenderLoaded=t},appenderMakers:{madeupappender:function(t,s){e.config=t,e.options=s}}}}}).configure({mode:"master",appender:{type:"madeupappender",cheese:"gouda"}},{crackers:"jacobs"});return e},"should load underlying appender for master":function(e){assert.equal(e.appenderLoaded,"madeupappender")},"should pass config to underlying appender":function(e){assert.equal(e.config.cheese,"gouda")},"should pass options to underlying appender":function(e){assert.equal(e.options.crackers,"jacobs")}}}).exportTo(module);